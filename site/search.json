{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Introduction","text":"","path":["Introduction"],"tags":[]},{"location":"#what-is-apexkit","level":3,"title":"What is ApexKit ?","text":"<p>ApexKit is an opinionated Next.js starter kit designed to help builders ship their projects faster — without the usual headaches of vendor lock-in or endless decision-making about tools and libraries.</p> <p>When you're a solo developer or part of a small team validating an idea — whether for a hackathon, an incubator, or your own startup — time spent configuring authentication, email services, UI components, or database setups takes valuable time away from focusing on your core idea and unique features. These are repetitive tasks that slow you down when speed is everything.</p> <p>But rapid prototyping shouldn’t come at the cost of performance, scalability, or future flexibility. Many \"quick-start\" solutions sacrifice performance, trap you in vendor ecosystems, or leave behind technical debt that becomes expensive — in both time and money — the moment your project gains traction. Suddenly, you’re stuck refactoring, migrating, or paying for subscriptions that don’t truly help you grow.</p> <p>ApexKit gives you the best of both worlds: the velocity of indie hacking and the clean, scalable foundation that production apps (and serious businesses) need from day one. </p>","path":["Introduction"],"tags":[]},{"location":"#whats-inside","level":4,"title":"What’s inside","text":"<ul> <li>Next.js 15 (App Router + React Server Components)</li> <li>Drizzle ORM : type-safe, SQL, and flexible enough to work with database solution of your choice. </li> <li>Tailwind CSS + DaisyUI – beautiful and accessible UI out of the box</li> <li>Better Auth : Fine-tuned, vendor-agnostic authentication</li> <li>Full TypeScript support</li> <li>Production-ready patterns for authentication and authorization. </li> </ul>","path":["Introduction"],"tags":[]},{"location":"#ready-to-give-it-a-try-get-started","level":4,"title":"Ready to give it a try ? [Get Started]","text":"","path":["Introduction"],"tags":[]},{"location":"#philosophy-principles","level":3,"title":"Philosophy / Principles","text":"<p>This short “Philosophy” section is a bit more candid and conversational than the rest of the docs — think of it as the \"why\" behind the choices. The rest of the documentation stays clean, concise, and to the point, I promise.</p> <p>Whether you’re an experienced developer checking for red flags or just getting started and curious about the reasoning, I hope it helps.</p>","path":["Introduction"],"tags":[]},{"location":"#opinionated","level":4,"title":"Opinionated","text":"<p>We won’t pretend otherwise: “best tool” is subjective. Some developers are perfectly happy (and productive) with MongoDB; others wouldn’t touch a non-relational database with a ten-foot pole. Some swear JavaScript has no place on the back-end; others run profitable, and secure businesses on it every day.</p> <p>That same spectrum exists when choosing a starter kit. Being opinionated isn’t about arrogance—it’s about making deliberate, battle-tested choices for two practical reasons:</p>","path":["Introduction"],"tags":[]},{"location":"#safety-through-familiarity","level":4,"title":"Safety Through Familiarity","text":"<p>Deep knowledge of a tool-set lets you anticipate its pitfalls and edge cases. A JavaScript developer who understands where Node.js can be notorious for memory leaks is just as safe as a seasoned Rust engineer who knows the same about their language (yes, you can still leak memory in Rust). Strong opinions come from real-world experience. They act as guardrails that keep most projects secure and stable by default.</p>","path":["Introduction"],"tags":[]},{"location":"#speed-that-actually-ships-products","level":4,"title":"Speed That Actually Ships Products","text":"<p>It’s incredibly easy and fun to chase the next hot framework or CSS library. I did it constantly in college: one assignment in React, the next in Vue, then Angular, then Gatsby. Curiosity and experimentation are how we grow as developers.</p> <p>But when you’re building something real — especially as a solo founder, small team, or side-project warrior with a day job—that mindset becomes expensive. Trying the shiny new thing might feel exciting, but it rarely helps you ship faster or sleep better at night.</p> <p>I wouldn’t reach for an experimental stack when helping a friend launch a platform for independent journalists on nights and weekends. Tempting? Absolutely. Responsible? Not even close.</p> <p>Some opinions of this project, briefly: </p> <ol> <li> <p>Drizzle ORM. </p> <p>Getting really good with a lightweight, type-safe ORM like Drizzle is a far better long-term investment than tying your data layer to platform-specific SDKs (Supabase, Firebase, Clerk, etc.). Those SDKs often create hidden problems:</p> <ul> <li>Painful refactoring when you outgrow or switch platforms</li> <li>Forced rewrites after breaking changes</li> <li>Vendor lock-in because migrating later costs more in time and opportunity than staying stuck</li> </ul> <p>With Drizzle, you own your schema and queries. You stay portable, type-safe, and in full control — no surprises when your project takes off. </p> </li> <li> <p>TypeScript</p> <p>Many developers have a love-hate relationship with JavaScript’s type system. You can go fully untyped, use JSDoc, or embrace TypeScript in various ways. ApexKit chooses full TypeScript because it can be adopted progressively, catches entire classes of bugs at compile time, and dramatically reduces runtime crashes.</p> </li> <li> <p>Better Auth</p> <p>Authentication and authorization are among the most crucial parts of any application. You need both and they need to be secure. With Better Auth, we get to roll a secure authentication system without being stuck with a vendor. We can own our data, set up backups that fit the business needs, and focus on building meaningful features. </p> <p>And with ApexKit, you do not have to worry about setting it up from scratch. All you have to do is provide a database connection, and you have a working authentication with sign-up, sign-in, reset password, email verification, magic links and even your transactional emails. And you can always extend for OTPs and two-factor authentication easily with Better Auth.</p> </li> <li> <p>Stability</p> <p>ApexKit is built for stability, and easy management. Refactoring doesn't need to break everything. Stability means being battle-tested and having the flexibility to evolve. Just like JavaScript, there are new UI frameworks being launched every day. But we use Tailwind CSS and DaisyUI to keep the project stable. You get a solid community, flexibility to build your own components with Tailwind, and speed of DaisyUI to get started quick. You get the stability of Better Auth's battle-tested auth system, flexibility of owning your data, and speed of Better Auth plugins to add more security features.</p> </li> </ol>","path":["Introduction"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"<p>Let's get you started on your \"next\" venture.</p> <ol> <li>Clone the repository from GitHub:     <pre><code>git clone https://github.com/pnpancholi/apexkit\n</code></pre></li> <li>Install dependencies (use your preferred package manager):     <pre><code>npm install\n# or\nyarn install\n# or\npnpm install\n</code></pre></li> <li>Start the development server:     <pre><code>npm run dev\n</code></pre></li> </ol> <p>Voilà! That's all you need to get started.</p> <p>You should see something like this in your browser.</p> <p></p>","path":["Getting Started"],"tags":[]},{"location":"support/","level":1,"title":"Support","text":"<p>All support questions, issues, and discussions live on GitHub. Please check the official support guidelines here → GitHub</p> <p>Thank you!</p>","path":["Support"],"tags":[]},{"location":"auth-module/authorization/","level":1,"title":"Authorization","text":"<p>To make life easier, Apex Kit comes with a built-in authorization module that makes sure if the user is authenticated before they can access a page or API route.</p> <pre><code>//auth/utils.ts\nexport async function requireAuth() {\n  const user = await getUser();\n  if (!user) {\n    redirect(\"/sign-in\");\n  }\n  return user;\n}\n</code></pre> <p>Under the hood, requireAuth checks the current session using better-auth's getSession() (or equivalent), and gracefully handles different environments: in Server Components / Route Handlers it redirects to your configured sign-in page (with optional redirect-back-to parameter), while in API routes it returns a clean 401 Unauthorized response. You can also customize the behavior with options like redirectTo, allowUnverified, or custom failure handlers — making it flexible enough for complex auth flows while keeping the default usage dead simple.</p> <p>You can use <code>requireAuth()</code> in your pages to protect them from unauthorized access.</p> <pre><code>// app/dashboard/page.tsx\n// Note: This page does not really exist in the Apex Kit codebase, its just an example\nimport { requireAuth } from '@/lib/auth/middleware';\nimport { getCurrentUser } from 'better-auth/next'; // or however you access the session/user\n\nexport default requireAuth(async function DashboardPage() {\n  const user = await getCurrentUser();\n\n  return (\n    &lt;div className=\"container mx-auto py-12 px-4\"&gt;\n      &lt;div className=\"card bg-base-100 shadow-xl max-w-2xl mx-auto\"&gt;\n        &lt;div className=\"card-body items-center text-center\"&gt;\n          &lt;h1 className=\"card-title text-3xl mb-6\"&gt;Welcome back, {user.name}!&lt;/h1&gt;\n\n          &lt;div className=\"avatar mb-4\"&gt;\n            &lt;div className=\"w-24 rounded-full ring ring-primary ring-offset-base-100 ring-offset-2\"&gt;\n              &lt;img \n                src={user.image || \"https://ui-avatars.com/api/?name=\" + encodeURIComponent(user.name || \"User\")} \n                alt=\"User avatar\" \n              /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          &lt;p className=\"text-lg mb-6\"&gt;\n            You're successfully authenticated with &lt;strong&gt;better-auth&lt;/strong&gt;.&lt;br/&gt;\n            This entire page is protected by &lt;code&gt;requireAuth&lt;/code&gt;.\n          &lt;/p&gt;\n\n          &lt;div className=\"card-actions\"&gt;\n            &lt;button className=\"btn btn-primary\"&gt;View Profile&lt;/button&gt;\n            &lt;button className=\"btn btn-outline\"&gt;Settings&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Quick status card */}\n      &lt;div className=\"stats shadow mt-8 w-full max-w-2xl mx-auto\"&gt;\n        &lt;div className=\"stat\"&gt;\n          &lt;div className=\"stat-title\"&gt;Email&lt;/div&gt;\n          &lt;div className=\"stat-value text-xl\"&gt;{user.email}&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div className=\"stat\"&gt;\n          &lt;div className=\"stat-title\"&gt;Joined&lt;/div&gt;\n          &lt;div className=\"stat-value text-xl\"&gt;\n            {user.createdAt ? new Date(user.createdAt).toLocaleDateString() : '—'}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n});\n</code></pre>","path":["Authentication Module","Authorization"],"tags":[]},{"location":"auth-module/email-and-password/","level":1,"title":"Email and Password","text":"<p>If you have performed all the tasks successfully in the previous section, you already have a working email and password authentication up and running with-in minutes. Your users can now do perform the following tasks : </p> <ol> <li>Create an account</li> <li>Visit their profile page (if authenticated)</li> <li>Update their email with a secure verification link</li> <li>Update their profile information (if authenticated)</li> <li>Reset password</li> </ol> <p></p>","path":["Authentication Module","Email and Password"],"tags":[]},{"location":"auth-module/email-and-password/#whats-in-the-package","level":3,"title":"What's In The Package ?","text":"<ol> <li>Sign-Up form</li> <li>Sign-In form</li> <li>Profile page</li> <li>Reset password page</li> <li>Email provider configuration</li> <li>Auth actions</li> <li><code>signUp</code></li> <li><code>signInWithPassword</code></li> <li><code>sendMagicLink</code></li> <li><code>requestPasswordReset</code></li> <li><code>resetPassword</code></li> <li><code>updateEmail</code></li> <li>A <code>requireAuth</code>  middleware for authorization</li> </ol>","path":["Authentication Module","Email and Password"],"tags":[]},{"location":"auth-module/email-and-password/#pages","level":3,"title":"Pages","text":"<p>All of the pages are kept in their named directories respectively as per the NextJS requirements and industry standards. In order to keep things organized and clean, these pages only consist the <code>JSX</code> and minimal logic required. This is a purely opinionated choice to keep the code-base balanced between  single responsibility and readable in order to keep it maintainable. \\ \\ In addition to that, the Sign In, Sign Up, Reset Password, and Forgot Password pages are intentionally rendered client-side , respectively. This is because they are for the most part small forms that need interactivity to communicate with users about progress. Using <code>useActionState</code> really helps in keeping code clean</p> <p>On the other hand, the Profile page is rendered on the server-side with an assumption that ideally your business needs will require you to add more things under profile . Rendering this will allow better loading times when you need to fetch a lot of data, provide snappy user experience like updating username , and serve as a hub to render other server or client side components as per your business need.\\ \\ An example for this would be.</p> <ol> <li> <p>Updating username </p> <ol> <li>Relies on server action</li> <li>Start editing the field, its intuitive </li> <li>Snappy reflection as user see their name updated right away</li> </ol> </li> <li> <p>Updating Email</p> <ol> <li>A client-side rendered modal wrapped inside Profile page</li> <li>Is not supposed to be used often, multi-click action</li> <li>Needs client interactivity (response) since change email requires more filtering than username. In addition to some tiny behaviors like closing upon Esc key or backdrop click</li> </ol> </li> </ol>","path":["Authentication Module","Email and Password"],"tags":[]},{"location":"auth-module/email-and-password/#actions","level":3,"title":"Actions","text":"<p>It can often get messy to have conditionally rendered JavaScript, CSS with HTTP requests and their error handling all in one file. And it can often lead to repeated code. A much cleaner approach would be to keep them separated. But an action file for each page which only contains one function can make navigation difficult and may still fail at keeping the code DRY.</p> <p>ApexKit handles this my keep all authentication functions in a single <code>auth.ts</code></p> <p>It further uses a custom type that is used through authentication functions for standard error handling. </p> <pre><code>// actions/auth.ts\ntype ActionResponse = { success: boolean; message: string };\n</code></pre> <p>And we encourage you to use the same pattern for a maintainable code-base.</p>","path":["Authentication Module","Email and Password"],"tags":[]},{"location":"auth-module/email-and-password/#security","level":3,"title":"Security","text":"<ol> <li>No duplicate emails , this works for both creating a new account and updating an email.</li> <li>When a user updates their email, a new verification email is sent to that new email.</li> <li>A regex filter for email to make sure its the correct format.</li> <li>About password, there is only a simple password filter to make sure that its at least four characters. This is intentionally kept simple for manual testing but can be easily modified to meet your standards. </li> </ol> <p>{% hint style=\"warning\" %} Its a must that you ship your project with a better password filter when you are ready for production.</p>","path":["Authentication Module","Email and Password"],"tags":[]},{"location":"auth-module/google-auth/","level":1,"title":"Google Authentication","text":"<p>In addition to email and password, ApexKit comes with Google authentication baked-in. Spending ~20 minutes is all you need to configure it. </p>","path":["Authentication Module","Google Authentication"],"tags":[]},{"location":"auth-module/google-auth/#setting-it-up","level":2,"title":"Setting It Up","text":"<ol> <li>Grab yourself a Google Cloud Platform account</li> <li>Create a new project in google cloud console.</li> <li>Copy your Client ID and Client Secret from the credentials page.</li> <li>Paste them into your environmanr variables <code>GOOGLE_CLIENT_ID</code>and  <code>GOOGLE_CLIENT_SECRET</code></li> </ol> <p>That's all you need to get Google authentication up and running. Now, your users can sign in using their Google account.</p>","path":["Authentication Module","Google Authentication"],"tags":[]},{"location":"auth-module/google-auth/#page","level":2,"title":"Page","text":"<p>In the <code>sign-in</code> page, you can see a button to sign in with Google.</p> <p>Google Authentication Page</p>","path":["Authentication Module","Google Authentication"],"tags":[]},{"location":"auth-module/google-auth/#action","level":2,"title":"Action","text":"<p>For the logic/action, we continue using our appraoching of keeping actions together for consistency. So, you can find the function inside <code>actions/auth</code> <pre><code>export async function signInWithGoogle() {\n  try {\n    const data = await authClient.signIn.social({ provider: \"google\", callbackURL: \"/profile\" })\n    console.log(\"social login\", data)\n\n  } catch (error) {\n    console.error(\"[signInWithGoogle]: Unexpected error\", error)\n    return { success: false, message: \"Something went wrong, Please try again later\" }\n  }\n}\n</code></pre></p> <p>You can futher modify this if you desire to but this is all that you need to do in order to get Google authentication up and running with ApexKit.</p>","path":["Authentication Module","Google Authentication"],"tags":[]},{"location":"auth-module/magic-link/","level":1,"title":"Magic Link","text":"<p>{% hint style=\"info\" %} Magic Links are enabled by default. This page exists to help you navigate how to modify things you you intend to.</p> <p>Magic Links offer one of the smoothest sign-up and login experiences for your users. By removing the need for passwords, you reduce friction and improve security.</p> <p>The best part? Magic Links are enabled by default. You don't have to spend hours on configuration—it is already set up to work out of the box. All you need is a Resend API key, and you’re ready to go. </p>","path":["Authentication Module","Magic Link"],"tags":[]},{"location":"auth-module/magic-link/#1-requirement","level":3,"title":"1. Requirement","text":"<p>To send emails, you simply need a Resend API key.</p> <p>Add your key to your <code>.env</code> file: <code>EMAIL_API_KEY=your_api_key.</code></p>","path":["Authentication Module","Magic Link"],"tags":[]},{"location":"auth-module/magic-link/#2-configuration","level":3,"title":"2. Configuration","text":"<p>The logic for Magic Links is handled within the <code>Better-Auth</code> configuration located in your <code>auth.ts</code> file.</p> <pre><code>// auth.ts (partial code)\n// Authentication with magicLink\n  plugins: [\n    magicLink({\n      sendMagicLink: async ({ email, token, url }, request) =&gt; {\n        await emailProvider.send(email, magicLinkTemplate(url))\n      },\n      expiresIn: 300,\n    }),\n  ],\n</code></pre> <p>You can reflect your own branding without relying on external template builders. All email templates are stored locally in <code>EmailTemplates.ts</code>, giving you full control over the HTML and styling.</p> <p>To modify the look and feel of your magic link emails, edit the <code>magicLinkTemplate</code> function:</p> <pre><code>// EmailTemplates.ts (partial code)\n\nexport const magicLinkTemplate = (url: string): EmailTemplate =&gt; ({\n  subject: \"Sign into your using magic link\",\n  html: `\n    &lt;div style=\"font-family: sans-serif; max-width: 600px; margin: auto; padding: 20px;\"&gt;\n      &lt;h2&gt;Sign in to your account&lt;/h2&gt;\n      &lt;p&gt;Click the button below to sign in with your magic link:&lt;/p&gt;\n      &lt;div style=\"text-align: center; margin: 30px 0;\"&gt;\n        &lt;a href=\"${url}\" style=\"background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;\"&gt;\n          Sign in\n        &lt;/a&gt;\n      &lt;/div&gt;\n      &lt;p style=\"color: #666; font-size: 14px;\"&gt;Or copy and paste this link:&lt;/p&gt;\n      &lt;p&gt;&lt;a href=\"${url}\" style=\"color: #0066ff;\"&gt;${url}&lt;/a&gt;&lt;/p&gt;\n      &lt;p style=\"color: #999; font-size: 12px;\"&gt;This link expires in 5 minutes.&lt;/p&gt;\n    &lt;/div&gt;\n  `\n})\n</code></pre> <p>You can edit this to reflect your branding without worrying about writing templates in some other platform and building dependency on it.</p> <p>{% hint style=\"info\" %} Branding Tip: Update the <code>background</code> color and <code>font-family</code> in the template above to match your brand's style guide instantly.</p>","path":["Authentication Module","Magic Link"],"tags":[]},{"location":"auth-module/magic-link/#3-magic-link-handler","level":3,"title":"3. Magic Link Handler","text":"<p>As you remember from the previous section that all of our authentication related functions are in a single actions/<code>auth.ts</code> file</p> <pre><code>// actions/auth.ts\nexport async function sendMagicLink(_: any, formData: FormData): Promise&lt;ActionResponse&gt; {\n  const email = formData.get(\"email\") as string;\n\n  try {\n    const { error } = await authClient.signIn.magicLink({\n      email,\n      callbackURL: \"/\",\n      newUserCallbackURL: \"/\",\n      errorCallbackURL: \"/\",\n    });\n    if (error) {\n      return { success: false, message: \"Sorry, we don't recognise that email\" };\n    } else {\n      return { success: true, message: \"Magic link is on its way\" };\n    }\n  } catch (error) {\n    console.error(\"[sendMagicLink]: Unexpected error\", error)\n    return { success: false, message: \"Something went wrong, Please try again later\" }\n  }\n}\n</code></pre>","path":["Authentication Module","Magic Link"],"tags":[]},{"location":"auth-module/magic-link/#4-usage-frontend","level":3,"title":"4. Usage (Frontend)","text":"<p>The sign-in page is already pre-wired to handle Magic Link requests. You can find the implementation in your login component. It uses the <code>authClient</code> to trigger the email delivery.</p> <pre><code>// sign-in/page.tsx (partial code)\n            {/*-----------------------Magic Link--------------------------------*/}\n            &lt;form className=\"space-y-4\"&gt;\n              &lt;input\n                name=\"email\"\n                type=\"email\"\n                placeholder=\"Email\"\n                className=\"input input-bordered w-full\"\n                required\n              /&gt;\n              {/*--------------------------Error Handling and response for magic link*/}\n              {magicLinkState &amp;&amp; (\n                &lt;&gt;\n                  {magicLinkState?.success === false &amp;&amp; (\n                    &lt;div className=\"alert alert-soft alert-error\"&gt;\n                      {magicLinkState.message}\n                    &lt;/div&gt;\n                  )}\n                  {magicLinkState.success === true &amp;&amp; (\n                    &lt;div className=\"alert alert-soft alert-success\"&gt;\n                      {magicLinkState.message}\n                    &lt;/div&gt;\n                  )}\n                &lt;/&gt;\n              )}\n              {/*--------------------------------------------------------------------*/}\n              &lt;button\n                type=\"submit\"\n                className=\"btn btn-secondary my-2\"\n                formAction={magicLinkAction}\n                disabled={magicLinkPending}\n              &gt;\n                {magicLinkPending ? \"Sending  Magic Link\" : \"Send Magic Link\"}\n              &lt;/button&gt;\n            &lt;/form&gt;\n</code></pre> <p>Key Benefits</p> <ul> <li>Zero Setup: Already integrated with Better-Auth.</li> <li>No External Dependencies: Manage your template directly in your codebase.</li> <li>Secure by Design: Short lived token prevent unauthorized access.</li> </ul>","path":["Authentication Module","Magic Link"],"tags":[]},{"location":"auth-module/setting-up/","level":1,"title":"Setting Up","text":"<p>In this day and age, your cannot ship a website with clunky feeling authentication. Your users deserve an email and password (standard, especially security conscious users who do not like linking accounts), sign-up and sign-in via magic links ( the growing favorite for its convenience) and social login options like Google, Meta, GitHub, etc. </p> <p>This Auth module is going to help you get a secure authentication up and running efficiently  including pages/views that you can easily customize if you desire to.</p>","path":["Authentication Module","Setting Up"],"tags":[]},{"location":"auth-module/setting-up/#what-comes-packed-in","level":3,"title":"What comes packed in ?","text":"<ol> <li>Email and Password authentication</li> <li>Magic Link Authentication</li> <li>Google Social Login (maybe)</li> <li>The <code>requireAuth</code> middle-ware for authorization</li> <li>Reset password functionality baked in</li> <li>Secure email update </li> <li>Crucial user interface (Sign In, Sign Up, Reset Password, Profile)</li> </ol>","path":["Authentication Module","Setting Up"],"tags":[]},{"location":"auth-module/setting-up/#connect-to-a-db","level":3,"title":"Connect to a DB.","text":"<p>First step to get authentication and authorization is to simply connect to a database to actually store our user data. Since ApexKit ships with the wonderful Better Auth. Nor you  are locked into any service like Okta or Clerk and neither you need to write roll-out your own authentication from scratch and spend your time writing hashing, salting and all the crucial pieces of authentication. \\ \\ We will use Supabase here for our DB. But you can use any PostgreSQL solution like Neon, Aiven Cloud, or  Railway.  </p> <p>https://supabase.com/docs/guides/database/connecting-to-postgres</p> <p>{% hint style=\"warning\" %} Note: We will use Supabase database, not Supabase Authentication</p> <ol> <li>Go to Supabase</li> <li>Create a free account.</li> <li>Set up your organization. </li> <li>Then simply create a new database for your project. This will prompt you to create a new database with a password. Keep this password safe with you. On your header, you should see a Connect button.</li> </ol> <p></p> <p>5. Get a connection string (that works with both IPv6 and IPv4)</p> <p>{% hint style=\"danger\" %} Important: We recommend using Transaction Pooler because Supabase uses IPv6 by default. And you might need IPv4 depending on where you are from. This is a way to avoid dealing with connection issues.</p> <p></p> <p>Your connection string should look something like this.\\ <code>postgresql://postgres.ivsfigwmvncndjncbgsz:[YOUR-PASSWORD]@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres</code></p> <p>{% hint style=\"info\" %} Heads Up: Make sure to swap the [Your-Password] with your actual password.</p> <ol> <li>Get your environment variables. </li> </ol> <p>You need three environment variables to get authentication up and running. They are,</p> <ul> <li><code>DATABASE_URL</code>  This is your db connection string</li> <li><code>BETTER_AUTH_SECRET</code>   A secret phrase that better-auth will use for operations like hashing.</li> <li><code>EMAIL_API_KEY</code> This will take care of sending emails for verification and magic links.</li> </ul> <p>There is an example file aptly named <code>.env.example</code> . Just use those variable names in your development and production.</p> <p>You can see how to get the <code>DATABASE_URL</code> in the previous section. For <code>BETTER_AUTH_SECRET</code> , you can choose any word or phrase. Just make sure to keep it safe. And lastly, for your <code>EMAIL_API_KEY</code> , grab one from https://resend.com/.</p> <p>{% hint style=\"info\" %} Note: This kit currently uses  Resend underneath for emails due to their generous free plan and affordable paid plans. [^1]</p> <ol> <li>Understanding the schema</li> </ol> <p>This kit ships with a Better-Auth compatible authentication schema with user, session, account, verification tables.  You can modify this table and add as many fields according to your own restrictions and flexibility as long as you provide the core fields that Better-Auth needs to help roll-out a secure authentication.</p> <p>We store all of our database related code in aptly named directory <code>db</code></p> <p>You can take a quick peek at the <code>auth</code> schema here:</p> <p>{% code expandable=\"true\" %} <pre><code>// db/schema/auth.ts\n\nimport { pgTable, text, timestamp, boolean, uuid } from \"drizzle-orm/pg-core\";\n\nexport const user = pgTable(\"user\", {\n  id: text(\"id\").primaryKey(), //Better-Auth expects this.\n  name: text(\"name\").notNull(),\n  email: text(\"email\").notNull().unique(), // one account per email\n  emailVerified: boolean(\"email_verified\").default(false),\n  image: text(\"image\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\nexport const session = pgTable(\"session\", {\n  id: text(\"id\").primaryKey(),\n  expiresAt: timestamp(\"expires_at\").notNull(),\n  token: text(\"token\").notNull().unique(),\n  userId: text(\"user_id\")\n    .notNull()\n    .references(() =&gt; user.id, { onDelete: \"cascade\" }),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(), // Better Auth NEEDS This\n  ipAddress: text(\"ip_address\"), // Better Auth NEEDS This - tracks user's IP\n  userAgent: text(\"user_agent\"), // Better Auth NEEDS This - tracks browser info\n});\n\nexport const account = pgTable(\"account\", {\n  id: text(\"id\").primaryKey(),\n  accountId: text(\"account_id\"), // Better Auth needs this\n  userId: text(\"user_id\")\n    .notNull()\n    .references(() =&gt; user.id, { onDelete: \"cascade\" }),\n  providerId: text(\"provider_id\").notNull(),\n  providerAccountId: text(\"provider_account_id\").notNull().default(\"none\"),\n  access_token: text(\"access_token\"),\n  refresh_token: text(\"refresh_token\"),\n  idToken: text(\"id_token\"),\n  accessTokenExpiresAt: timestamp(\"access_token_expires_at\"),\n  refreshTokenExpiresAt: timestamp(\"refresh_token_expires_at\"),\n  scope: text(\"scope\"),\n  password: text(\"password\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\nexport const verificationToken = pgTable(\"verification_table\", {\n  identifier: text(\"identifier\").notNull(),\n  token: text(\"token\").notNull(),\n  expires: timestamp(\"expires\").notNull(),\n});\nexport const verification = pgTable(\"verification\", {\n  id: text(\"id\").primaryKey(),\n  identifier: text(\"identifier\").notNull(),\n  value: text(\"value\").notNull(),\n  expiresAt: timestamp(\"expires_at\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow(),\n});\n</code></pre></p> <ol> <li>Talking to your database.</li> </ol> <p>The ApexKit uses two libraries to make authentication work without vendor lock-ins. Better-Auth library to give us all the authentication features like email and password, magic links, sessions, two-factor authentication and much more. And then we use Drizzle to actually talk to our database and store information in it. \\ \\ In order to move forwards, once you have settled on your <code>auth</code> schema (stick to the default or update according to your needs), we need to validate and push it to our database.\\ \\ You have your database, but it needs tables, relational mapping, restrictions etc. You may even need to update this later on after you have already stored some user data. We can do all of this with drizzle-kit.\\ \\ This kit has simple scripts to make easier for you to perform these operations.</p> <pre><code>// package json\n    \"db:gen\": \"drizzle-kit generate\",\n    \"db:push\": \"drizzle-kit push\",\n    \"db:migrate\": \"drizzle-kit migrate\"\n</code></pre> <p>Some familiarity with SQL and Relational Databases would be helpful here. But if you haven't worked with them before, it's okay. This kit will reduce overhead significantly and you can pick-it up as you go you would like to.</p> <p>Changes in your database schema are stored under \"migrations\". If you change anything in your schema, you need to make sure it is valid i.e it works well with existing database and doesn't break things. And all of our migrations are configured to store inside <code>db</code> directory.</p> <p>We will primarily use <code>npm run db:gen</code> and <code>npm run db:migrate</code>. The command <code>npm run db:push</code> is only used during testing but not ideal for production. </p> <p><code>npm run db:gen</code>  will check if you made any changes to your schema files compared to last migrations.</p> <p><code>npm run db:migrate</code> will perform this migrations (changes) to your database safely. This can be anything like adding a new field or changing default value.</p> <p>After performing these two commands, you should  see tables created in your database. </p> <p>{% hint style=\"success\" %} Congratulations! You just setup your project with a working authentication. And you did that efficiently.</p> <p>Let's move further to understand how authentication is wired so you can modify things if you want and/or need to. </p>","path":["Authentication Module","Setting Up"],"tags":[]},{"location":"db-module/configuration/","level":1,"title":"Database Configuration","text":"<p>Apexkit is built with the Drizzle ORM. All of the database related files are stored inside src/db directory from schema to migrations. You can find all of this configuration inside the <code>drizzle.config.ts</code> file. </p> <pre><code>import { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  out: \"./src/db/migrations\",\n  schema: \"./src/db/schema/\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n    //forcing IPv4\n    host: new URL(process.env.DATABASE_URL!).hostname,\n  },\n  verbose: true, // For debugging\n});\n</code></pre>","path":["Database Module","Database Configuration"],"tags":[]},{"location":"db-module/configuration/#schemas","level":2,"title":"Schemas","text":"<p>You can see the authentication schema inside the <code>src/db/schema/auth.ts</code> file. This file consists of all the tables that we need for authentication. </p> <pre><code>// src/db/schema/auth.ts \n// User table\nexport const user = pgTable(\"user\", {\n  id: text(\"id\").primaryKey(), //Better-Auth expects this.\n  name: text(\"name\").notNull(),\n  email: text(\"email\").notNull().unique(), // one account per email\n  emailVerified: boolean(\"email_verified\").default(false),\n  image: text(\"image\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n</code></pre> <p>In addition to this, all of the migration files are inside the same <code>db</code> directory. These are created whenever you perform any changes in the DB schema using drizzle-kit as long as it's a valid. </p>","path":["Database Module","Database Configuration"],"tags":[]},{"location":"db-module/configuration/#tying-it-all-together","level":2,"title":"Tying it all together.","text":"<p>To simplify database workflows, this kit comes with a couple of scripts. </p> <pre><code>{\n    scripts\": {\n        \"dev\": \"next dev\",\n        \"build\": \"next build\",\n        \"start\": \"next start\",\n        \"db:gen\": \"drizzle-kit generate\",\n        \"db:push\": \"drizzle-kit push\",\n        \"db:migrate\": \"drizzle-kit migrate\"\n    },\n}\n</code></pre> <ol> <li>Generate - Generates a migration file based on your newly created schema or a change to an existing one.</li> <li>Migrates - Applies the generated migration file to your database after performing checks.</li> <li>Push - Pushes the migration file into your database, omitting the SQL file changes. Ideally only performed during development.</li> </ol>","path":["Database Module","Database Configuration"],"tags":[]},{"location":"db-module/updating-db/","level":1,"title":"Updating your hosted database","text":"<p>This guide will help you update your hosted database. It is nornmal to find yourself in a position where you need to update the services you are using for your business or project. Maybe you are using Supabase and need to move to AWS because it is more cost-effective or the other way around because you find Supabase easier to work with. These kinds of migrations are often easier when working with ORM tools and \"Code As Schema\" tools. Since we are maintaining the source of truth with Drizzle, switching to another database solution is easy.</p>","path":["Database Module","Updating your hosted database"],"tags":[]},{"location":"db-module/updating-db/#generating-a-migration-file-optional","level":2,"title":"Generating a Migration File (Optional)","text":"<p>You will need to create a migration file with <code>npm run db:gen</code> if you made any changes to your schema. Otherwise, just ignore this step. You have all the migration files that you need.</p>","path":["Database Module","Updating your hosted database"],"tags":[]},{"location":"db-module/updating-db/#pushing-your-schema-to-the-new-database","level":2,"title":"Pushing Your Schema to the New Database","text":"<p>This kit is designed with modularity and freedom of choice in mind.</p> <p>First, we will change the environment variable. Just get your new database URL and update it in the <code>.env</code> file. Note that it works with PostgreSQL only for now. Now just run <code>npm run db:migrate</code> and voila! You are good to go.</p> <p>Note: You still need to perform a data migration to your new hosted solution.</p>","path":["Database Module","Updating your hosted database"],"tags":[]},{"location":"db-module/updating-schema/","level":1,"title":"Updating your existing schema","text":"<p>This page will guide you through updating your existing schema. Drizzle makes it quite easy to update your existing schema. Let's say you want to create a new field in your existing schema, then you can simply add a new column to your schema file.</p> <pre><code>// db/schema/auth.ts\n\nexport const user = pgTable(\"user\", {\n  id: text(\"id\").primaryKey(), \n  name: text(\"name\").notNull(),\n  bio: text(\"null\").notNull(), // new field\n  email: text(\"email\").notNull().unique(),\n  emailVerified: boolean(\"email_verified\").default(false),\n  image: text(\"image\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n</code></pre> <p>Now you can run the <code>npm run db:gen</code> script to generate a new migration file. And <code>npm run db:migrate</code> to apply the changes to your database.</p>","path":["Database Module","Updating your existing schema"],"tags":[]},{"location":"db-module/updating-schema/#fixing-updating","level":2,"title":"Fixing / Updating","text":"<p>Maybe you made a typo in the schema file? </p> <pre><code>// Example of typo\n\nexport const user = pgTable(\"user\", {\n  id: text(\"id\").primaryKey(), \n  name: text(\"nmae\").notNull(), // accidental typo\n  bio: text(\"null\").notNull(), // new field\n  email: text(\"email\").notNull().unique(),\n  emailVerified: boolean(\"email_verified\").default(false),\n  image: text(\"image\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n</code></pre> <p>You can see the line where \"name\" is misspelled with \"nmae\". No problem, Drizzle-Kit makes it easy to deal with this. All you need to do is update the schema file and run the <code>npm run db:gen</code> script. Drizzle Kit will prompt you asking whether this is a rename or a new column. Just answer 'yes' to the rename prompt, and your database will be updated automatically.</p>","path":["Database Module","Updating your existing schema"],"tags":[]},{"location":"ui-module/built-in-themes/","level":1,"title":"Daisy UI: Built-in themes","text":"","path":["UI Module","Daisy UI: Built-in themes"],"tags":[]},{"location":"ui-module/built-in-themes/#beautiful-uis-built-in-minutes","level":3,"title":"Beautiful UIs, Built in Minutes","text":"<p>This starter ships with Tailwind CSS + Daisy UI pre-configured and ready to go — the perfect combo for developers who want speed without sacrificing beauty or flexibility.</p> <ol> <li> <p>The Power Duo: Tailwind CSS + Daisy UI Wide ecosystem You’re not starting from scratch. You’re plugged into the massive Tailwind ecosystem — thousands of plugins, component libraries, templates, and tutorials. Daisy UI sits on top and adds production-ready, accessible components (buttons, cards, modals, drawers, dropdowns, tables, and more) that follow Tailwind’s utility-first philosophy. Whatever you need, the community has already solved it. Lightning-fast development Stop writing the same button styles over and over. Daisy UI gives you clean, semantic classes like btn btn-primary, card, drawer, navbar, hero — all fully responsive and dark-mode ready out of the box. Build pixel-perfect interfaces 3–5× faster than plain Tailwind, while keeping 100% control. No magic, no bloat — just pure Tailwind under the hood.</p> </li> <li> <p>Instant Visual Appeal with Built-in Themes Why ship another boring gray-and-blue app? Daisy UI comes with 20+ gorgeous themes (light, dark, pastel, cyberpunk, luxury, corporate, and more) that you can switch with a single class or data attribute.</p> </li> </ol> <p>Pick a theme in seconds and your entire app looks polished and modern instantly. It’s the sweet spot between “ugly default starter” and “heavy design-system overhead”. No Figma-to-code nightmares. No months of design debt.</p> <p>When your team or client is ready, simply progressively evolve it:</p> <p>Start with any built-in theme Tweak a few variables and thats it Replace with your company’s full branding (colors, typography, logos, custom components) progressively Keep using the same Daisy UI classes — everything just adapts.</p> <p>Zero lock-in. Total freedom.</p>","path":["UI Module","Daisy UI: Built-in themes"],"tags":[]},{"location":"ui-module/custom-themes/","level":1,"title":"Daisy UI: Buildinig Custom Themes","text":"<p>As your project grows, its natural work on branding and customization. In addition to performance and a good user experience, an identity is important. With Daisy UI, you can easily create a custom theme to match the look and feel of your brand progressively.</p> <p>Once you have settled on your colors and typography for the theme. You can add them in your <code>global.css</code> file. Make sure to import libraries in the correct order.</p> <pre><code>@import \"tailwindcss\";\n@plugin \"daisyui\";\n@plugin \"daisyui/theme\" {\n  name: \"mytheme\";\n  default: true; /* set as default */\n  prefersdark: false; /* set as default dark mode (prefers-color-scheme:dark) */\n  color-scheme: light; /* color of browser-provided UI */\n\n  --color-base-100: oklch(98% 0.02 240);\n  --color-base-200: oklch(95% 0.03 240);\n  --color-base-300: oklch(92% 0.04 240);\n  --color-base-content: oklch(20% 0.05 240);\n  --color-primary: oklch(55% 0.3 240);\n  --color-primary-content: oklch(98% 0.01 240);\n  --color-secondary: oklch(70% 0.25 200);\n  --color-secondary-content: oklch(98% 0.01 200);\n  --color-accent: oklch(65% 0.25 160);\n  --color-accent-content: oklch(98% 0.01 160);\n  --color-neutral: oklch(50% 0.05 240);\n  --color-neutral-content: oklch(98% 0.01 240);\n  --color-info: oklch(70% 0.2 220);\n  --color-info-content: oklch(98% 0.01 220);\n  --color-success: oklch(65% 0.25 140);\n  --color-success-content: oklch(98% 0.01 140);\n  --color-warning: oklch(80% 0.25 80);\n  --color-warning-content: oklch(20% 0.05 80);\n  --color-error: oklch(65% 0.3 30);\n  --color-error-content: oklch(98% 0.01 30);\n\n  /* border radius */\n  --radius-selector: 1rem;\n  --radius-field: 0.25rem;\n  --radius-box: 0.5rem;\n\n  /* base sizes */\n  --size-selector: 0.25rem;\n  --size-field: 0.25rem;\n\n  /* border size */\n  --border: 1px;\n\n  /* effects */\n  --depth: 1;\n  --noise: 0;\n}\n</code></pre> <p>The best part? You can do this progressively. And Daisy UI enables you to customize it throughly. You can customize</p> <ol> <li> <p>Existing themes - Maybe you like a theme and just wanna change it fonts or a specific color. Or maybe just a different hue.</p> </li> <li> <p>Custom components - Use uitlity classes to create your own components with the touch and feel of your own choices.</p> </li> <li> <p>Creating your own custom theme - As we have seen above, it is that easy to implement your own theme.</p> </li> </ol>","path":["UI Module","Daisy UI: Buildinig Custom Themes"],"tags":[]},{"location":"ui-module/custom-themes/#references","level":3,"title":"References","text":"<ol> <li> <p>Customizing your components: https://daisyui.com/docs/customize/</p> </li> <li> <p>Creating a custom theme: https://daisyui.com/docs/themes/</p> </li> </ol>","path":["UI Module","Daisy UI: Buildinig Custom Themes"],"tags":[]}]}